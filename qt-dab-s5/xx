926d925
< 	
931d929
< 	ed. channel	= channel. channelName;
937,943d934
< 	ed. isAudio = my_dabProcessor -> is_audioService (serviceName);
< 	if (ed. isAudio) {
< 	   audiodata ad;
< 	      my_dabProcessor -> dataforAudioService (serviceName, &ad);
< 	   ed. programType =
< 	      ad. programType;
< 	}
951,1323d941
< 	    model. appendRow (new QStandardItem (serv. name));
< 	}
< 	for (int i = 0; i < model. rowCount (); i ++) {
< 	   model. setData (model. index (i, 0),
< 	              QFont (theFont, fontSize), Qt::FontRole);
< 	}
< 
< 	ensembleDisplay -> setModel (&model);
< 	if (serviceCount == model.rowCount () && !scanning) {
< 	   presetTimer. stop ();
< 	   setPresetStation ();
< 	}
< }
< //
< //	The ensembleId is written as hexadecimal, however, the 
< //	number display of Qt is only 7 segments ...
< static
< QString hextoString (int v) {
< QString res;
< 	for (int i = 0; i < 4; i ++) {
< 	   uint8_t t = (v & 0xF000) >> 12;
< 	   QChar c = t <= 9 ? (char)('0' + t) : (char) ('A' + t - 10);
< 	   res. append (c);
< 	   v <<= 4;
< 	}
< 	return res;
< }
< 
< ///	a slot, called by the fib processor
< void	RadioInterface::nameofEnsemble (int id, const QString &v) {
< QString s;
< 	if (!running. load())
< 	   return;
< 
< 	QFont font	= ensembleId -> font ();
< 	font. setPointSize (14);
< //	font. setBold (true);
< 	ensembleId	-> setFont (font);
< //	ensembleId	-> setAlignment(Qt::AlignCenter);
< 	ensembleId	-> setText (v + QString ("(") + hextoString (id) + QString (")"));
< 
< 	channel. ensembleName	= v;
< 	channel. Eid		= id;
< 	channel. countryName	= "";
< 	channel. transmitterName	= "";
< 	channel. has_ecc	= false;
< 	channel. ecc_byte	= 0;
< 	channel. countryName	= "";
< 	channel. mainId		= 0;
< 	channel. subId		= 0;
< 	channel. nrTransmitters	= 0;
< 	if (configWidget. scanmodeSelector -> currentIndex () == SCAN_TO_DATA)
< 	   stopScanning (false);
< }
< //
< ///////////////////////////////////////////////////////////////////////////
< 
< void	RadioInterface::handle_contentButton	() {
< QStringList s	= my_dabProcessor -> basicPrint ();
< 
< 	if (my_contentTable != nullptr) {
< 	   my_contentTable -> hide ();
< 	   delete my_contentTable;
< 	   my_contentTable = nullptr;
< 	   return;
< 	}
< 	QString theTime;
< 	QString SNR	= "SNR " + QString::number (configWidget. snrDisplay -> value ());
< 	if (configWidget. utcSelector -> isChecked ())
< 	   theTime	= convertTime (UTC. year,  UTC. month,
< 	                               UTC. day, UTC. hour, UTC. minute);
< 	else
< 	   theTime	= convertTime (localTime. year,  localTime. month,
< 	                               localTime. day, localTime. hour,
< 	                               localTime. minute);
< 
< 	QString header		= channel. ensembleName + ";" +
< 	                          channel. channelName  + ";" +
< 	                          QString::number (channel. frequency) + ";" +
< 	                          hextoString (channel. Eid) + " " + ";" +
< 	                          transmitter_coordinates -> text () + " " + ";" +
< 	                          theTime  + ";" +
< 	                          SNR  + ";" +
< 	                          QString::number (serviceList. size ()) + ";" +
< 	                          distanceLabel -> text ();
< 
< 	my_contentTable		= new contentTable (this, dabSettings,
< 	                                            channel. channelName,
< 	                                            my_dabProcessor -> scanWidth ());
< 	connect (my_contentTable, SIGNAL (goService (const QString &)),
< 	         this, SLOT (handle_contentSelector (const QString &)));
< 
< 
< 	my_contentTable		-> addLine (header);
< 	my_contentTable		-> addLine ("\n");
< 	for (int i = 0; i < s. size (); i ++) 
< 	   my_contentTable	-> addLine (s. at (i));
< 	my_contentTable -> show ();
< }
< 
< QString	RadioInterface::checkDir (const QString s) {
< QString	dir = s;
< 
< 	if (!dir. endsWith (QChar ('/')))
< 	   dir += QChar ('/');
< 
< 	if (QDir (dir). exists())
< 	   return dir;
< 	QDir (). mkpath (dir);
< 	return dir;
< }
< 
< void	RadioInterface::handle_motObject (QByteArray result,
< 	                                  QString objectName,
< 	                                  int contentType, bool dirElement) {
< QString realName;
< 
< #ifdef	XXX
< 	fprintf (stderr, "handle_MOT: type %x (%x %x), name %s dir = %d\n",
< 	                           contentType,
< 	                           getContentBaseType ((MOTContentType)contentType),
< 	                           getContentSubType ((MOTContentType)contentType),
< 	                           objectName. toUtf8 (). data (), dirElement);
< #endif
< 	switch (getContentBaseType ((MOTContentType)contentType)) {
< 	   case MOTBaseTypeGeneralData:
< 	      break;
< 
< 	   case MOTBaseTypeText:
< 	      save_MOTtext (result, contentType, objectName);
< 	      break;
< 
< 	   case MOTBaseTypeImage:
< 	      show_MOTlabel (result, contentType, objectName, dirElement);
< 	      break;
< 
< 	   case MOTBaseTypeAudio:
< 	      break;
< 
< 	   case MOTBaseTypeVideo:
< 	      break;
< 
< 	   case MOTBaseTypeTransport:
< 	      save_MOTObject (result, objectName);
< 	      break;
< 
< 	   case MOTBaseTypeSystem:
< 	      break;
< 
< 	   case  MOTBaseTypeApplication: 	// epg data
< 	      if (epgPath == "")
< 	         return;
< 
< 	      if (objectName == QString (""))
< 	         objectName = "epg file";
< 	      objectName  = epgPath + objectName;
< 
< 	      {
< 	         QString temp = objectName;
< 	         temp = temp. left (temp. lastIndexOf (QChar ('/')));
< 	         if (!QDir (temp). exists ())
< 	            QDir (). mkpath (temp);	
< 
< 	         std::vector<uint8_t> epgData (result. begin(),
< 	                                                  result. end());
< 	         uint32_t ensembleId =
< 	                     my_dabProcessor -> get_ensembleId ();
< 	         uint32_t currentSId =
< 	                     extract_epg (objectName, serviceList, ensembleId);
< 	         uint32_t julianDate	=
< 	                     my_dabProcessor -> julianDate ();
< 	         int subType = 
< 	                  getContentSubType ((MOTContentType)contentType);
< 	         epgProcessor. process_epg (epgData. data (), 
< 	                                    epgData. size (), currentSId,
< 	                                    subType,
< 	                                    julianDate);
< 	         if (configWidget. epg2xmlSelector -> isChecked ()) {
< 	            epgHandler. decode (epgData,
< 	                      QDir::toNativeSeparators (objectName));
< 	         }
< 	      }
< 	      return;
< 
< 	   case MOTBaseTypeProprietary:
< 	      break;
< 	}
< }
< 
< void	RadioInterface::save_MOTtext (QByteArray &result,
< 	                              int contentType,  QString name) {
< 	(void)contentType;
< 	if (filePath == "")
< 	   return;
< 
< 	QString textName = QDir::toNativeSeparators (filePath + name);
< 
< 	FILE *x = fopen (textName. toUtf8 (). data (), "w+b");
< 	if (x == nullptr)
< 	   fprintf (stderr, "cannot write file %s\n",
< 	                            textName. toUtf8 (). data ());
< 	else {
< 	   fprintf (stderr, "going to write file %s\n",
< 	                            textName. toUtf8(). data());
< 	   (void)fwrite (result. data (), 1, result.length(), x);
< 	   fclose (x);
< 	}
< }
< 
< void	RadioInterface::save_MOTObject (QByteArray  &result,
< 	                                  QString name) {
< 	if (filePath == "")
< 	   return;
< 
< 	if (name == "") {
< 	   static int counter	= 0;
< 	   name = "motObject_" + QString::number (counter);
< 	   counter ++;
< 	}
< 	save_MOTtext (result, 5, name);
< }
< 
< //	MOT slide, to show
< void	RadioInterface::show_MOTlabel	(QByteArray  &data,
< 	                                 int contentType,
< 	                                 QString pictureName,
< 	                                 int dirs) {
< const char *type;
< 	if (!running. load() || (pictureName == QString ("")))
< 	   return;
< 
< 	switch (static_cast<MOTContentType>(contentType)) {
< 	   case MOTCTImageGIF:
< 	      type = "GIF";
< 	      break;
< 
< 	   case MOTCTImageJFIF:
< 	      type = "JPG";
< 	      break;
< 
< 	   case MOTCTImageBMP:
< 	      type = "BMP";
< 	      break;
< 
< 	   case MOTCTImagePNG:
< 	      type = "PNG";
< 	      break;
< 
< 	   default:
< 	        return;
< 	}
< 
< 	if (configWidget. saveSlides  -> isChecked () 
< 	                               && (picturesPath != "")) {
< 	   QString pict = picturesPath + pictureName;
< 	   QString temp = pict;
< 	   temp = temp. left (temp. lastIndexOf (QChar ('/')));
< 	   if (!QDir (temp). exists())
< 	      QDir (). mkpath (temp);	
< 	   pict		= QDir::toNativeSeparators (pict);
< 	   FILE *x = fopen (pict. toUtf8 (). data (), "w+b");
< 
< 	   if (x == nullptr)
< 	      fprintf (stderr, "cannot write file %s\n",
< 	                            pict. toUtf8 (). data ());
< 	   else {
< 	      fprintf (stderr, "going to write file %s\n",
< 	                            pict. toUtf8(). data());
< 	      (void)fwrite (data. data(), 1, data.length(), x);
< 	      fclose (x);
< 	   }
< 	}
< 	
< 	if (!currentService. is_audio)
< 	   return;
< 
< //	if (dirs != 0)
< //	   return;
< 
< 	QPixmap p;
< 	p. loadFromData (data, type);
< 	int w   = 400;
< 	int h   = 2 * w / 3.5;
< 	pictureLabel	-> setAlignment(Qt::AlignCenter);
< 	pictureLabel ->
< 	       setPixmap (p. scaled (w, h, Qt::KeepAspectRatio));
< 	pictureLabel -> show ();
< }
< //
< //	sendDatagram is triggered by the ip handler,
< void	RadioInterface::sendDatagram	(int length) {
< uint8_t localBuffer [length];
< 
< 	if (dataBuffer. GetRingBufferReadAvailable() < length) {
< 	   fprintf (stderr, "Something went wrong\n");
< 	   return;
< 	}
< 
< 	dataBuffer. getDataFromBuffer (localBuffer, length);
< #ifdef	_SEND_DATAGRAM_
< 	if (running. load()) {
< 	   dataOut_socket. writeDatagram ((const char *)localBuffer, length,
< 	                                   QHostAddress (ipAddress),
< 	                                   port);
< 	}
< 	
< #endif
< }
< //
< //	tdcData is triggered by the backend.
< void	RadioInterface::handle_tdcdata (int frametype, int length) {
< #ifdef DATA_STREAMER
< uint8_t localBuffer [length + 8];
< #endif
< 	(void)frametype;
< 	if (!running. load())
< 	   return;
< 	if (dataBuffer. GetRingBufferReadAvailable() < length) {
< 	   fprintf (stderr, "Something went wrong\n");
< 	   return;
< 	}
< #ifdef	DATA_STREAMER
< 	dataBuffer. getDataFromBuffer (&localBuffer [8], length);
< 	localBuffer [0] = 0xFF;
< 	localBuffer [1] = 0x00;
< 	localBuffer [2] = 0xFF;
< 	localBuffer [3] = 0x00;
< 	localBuffer [4] = (length & 0xFF) >> 8;
< 	localBuffer [5] = length & 0xFF;
< 	localBuffer [6] = 0x00;
< 	localBuffer [7] = frametype == 0 ? 0 : 0xFF;
< 	if (running. load())
< 	   dataStreamer -> sendData (localBuffer, length + 8);
< #endif
< }
< 
< /**
<   *	If a change is detected, we have to restart the selected
<   *	service - if any. If the service is a secondary service,
<   *	it might be the case that we have to start the main service
<   *	how do we find that?
<   *
<   *	Response to a signal, so we presume that the signaling body exists
<   *	signal may be pending though
<   */
< void	RadioInterface::changeinConfiguration () {
< int	serviceOrder;
< 	if (!running. load () || my_dabProcessor == nullptr)
< 	   return;
< 	dabService s;
< 	if (currentService. valid) 
< 	   s = currentService;
< 	stopService	(s);
< 	stopScanning    (false);
< //
< //
< //	we stop all secondary services as well, but we maintain theer
< //	description, file descriptors remain of course
< //
< 	for (uint16_t i = 0; i < backgroundServices. size (); i ++)
< 	   my_dabProcessor -> stopService (backgroundServices. at (i). subChId,
< 	                                   BACK_GROUND);
< 
< 	fprintf (stderr, "change will be effected\n");
< 	serviceOrder	= 
< 	        dabSettings -> value ("serviceOrder", ALPHA_BASED). toInt ();
< 
< 	
< //	we rebuild the services list from the fib and
< //	then we (try to) restart the service
< 	serviceList	= my_dabProcessor -> getServices (serviceOrder);
< 	model. clear	();
< 	for (auto serv : serviceList)
1325,3243d942
< 	int row = model. rowCount ();
< 	for (int i = 0; i < row; i ++) {
< 	   model. setData (model. index (i, 0),
< 	   QFont (theFont, fontSize), Qt::FontRole);
< 	}
< 	ensembleDisplay -> setModel (&model);
< //
< 	if (etiActive)
< 	   my_dabProcessor -> reset_etiGenerator ();
< 
< //	Of course, it may be disappeared
< 	if (s. valid) {
< 	   QString ss = my_dabProcessor -> findService (s. SId, s. SCIds);
< 	   if (ss != "") {
< 	      startService (&s);
< 	      return;
< 	   }
< //
< //	The service is gone, it may be the subservice of another one
< 	   s. SCIds = 0;
< 	   s. serviceName =
< 	               my_dabProcessor -> findService (s. SId, s. SCIds);
< 	   if (s. serviceName != "")
< 	      startService (&s);
< 	}
< //
< //	we also have to restart all background services,
< 	for (uint16_t i = 0; i < backgroundServices. size (); i ++) {
< 	   QString ss = my_dabProcessor -> findService (s. SId, s. SCIds);
< 	   if (ss == "") {	// it is gone, close the file if any
< 	      if (backgroundServices. at (i). fd != nullptr)
< 	         fclose (backgroundServices. at (i). fd);
< 	      backgroundServices. erase
< 	                        (backgroundServices. begin () + i);
< 	   }
< 	   else {	// (re)start the service
< 	      if (my_dabProcessor -> is_audioService (ss)) {
< 	         audiodata ad;
< 	         FILE *f = backgroundServices. at (i). fd;
< 	         my_dabProcessor -> dataforAudioService (ss, &ad);
< 	         my_dabProcessor -> 
< 	                   set_audioChannel (&ad, &audioBuffer, f, BACK_GROUND);	       
< 	         backgroundServices. at (i). subChId     = ad. subchId;
< 	      }
< 	      else {
< 	         packetdata pd;
< 	         my_dabProcessor -> dataforPacketService (ss, &pd, 0);
< 	         my_dabProcessor -> 
< 	                   set_dataChannel (&pd, &dataBuffer, BACK_GROUND);	       
< 	         backgroundServices. at (i). subChId     = pd. subchId;
< 	      }
< 	      for (int j = 0; j < model. rowCount (); j ++) {
< 	         QString itemText =
< 	                           model. index (j, 0). data (Qt::DisplayRole). toString ();
< 	         if (itemText == ss) {
< 	            colorService (model. index (j, 0), Qt::blue,
< 	                                fontSize + 2, true);
< 	         }
< 	      }
< 	   }
< 	}
< }
< //
< //	In order to not overload with an enormous amount of
< //	signals, we trigger this function at most 10 times a second
< //
< void	RadioInterface::newAudio	(int amount, int rate) {
< 	if (running. load ()) {
< 	   int16_t vec [amount];
< 	   while (audioBuffer. GetRingBufferReadAvailable() > amount) {
< 	      audioBuffer. getDataFromBuffer (vec, amount);
< #ifdef	HAVE_PLUTO_RXTX
< 	      if (streamerOut != nullptr)
< 	         streamerOut	-> audioOut (vec, amount, rate);
< #endif
< 	      if (!muteTimer. isActive ())
< 	         soundOut	-> audioOut (vec, amount, rate);
< 	   }
< 	}
< }
< //
< 
< /////////////////////////////////////////////////////////////////////////////
< //	
< /**
<   *	\brief TerminateProcess
<   *	Pretty critical, since there are many threads involved
<   *	A clean termination is what is needed, regardless of the GUI
<   */
< void	RadioInterface::TerminateProcess () {
< 	if (scanning. load ())
< 	   stopScanning (false);
< 	running. store	(false);
< 	dumpControlState (dabSettings);
< 	hideButtons	();
< #ifdef	DATA_STREAMER
< 	fprintf (stderr, "going to close the dataStreamer\n");
< 	delete		dataStreamer;
< #endif
< #ifdef	CLOCK_STREAMER
< 	fprintf (stderr, "going to close the clockstreamer\n");
< 	delete	clockStreamer;
< #endif
< 	if (mapHandler != nullptr)
< 	   mapHandler ->  stop ();
< 	displayTimer.	stop	();
< 	channelTimer.	stop	();
< 	presetTimer.	stop	();
< 	epgTimer.	stop	();
< 	soundOut	-> stop ();
< 	if (dlTextFile != nullptr)
< 	   fclose (dlTextFile);
< #ifdef	HAVE_PLUTO_RXTX
< 	if (streamerOut != nullptr)
< 	   streamerOut	-> stop ();
< #endif
< 	if (my_dabProcessor != nullptr)
< 	   my_dabProcessor -> stop ();
< 	if (my_contentTable != nullptr) {
< 	   my_contentTable -> clearTable ();
< 	   my_contentTable -> hide ();
< 	   delete my_contentTable;
< 	}
< 	if (my_scanTable != nullptr) {
< 	   my_scanTable	-> clearTable ();
< 	   my_scanTable	-> hide ();
< 	   delete my_scanTable;
< 	}
< 	my_presetHandler. savePresets (presetSelector);
< 	theBand. saveSettings	();
< 	stop_frameDumping	();
< 	stop_sourceDumping	();
< 	stop_audioDumping	();
< //	theTable. hide		();
< 	theBand. hide		();
< 	theScheduler. hide	();
< 	configDisplay. hide	();
< 	dataDisplay. hide	();
< 	LOG ("terminating ", "");
< 	usleep (1000);		// pending signals
< 	if (logFile != nullptr)
< 	   fclose (logFile);
< 	logFile	= nullptr;
< //	everything should be halted by now
< 
< 	dabSettings	-> sync ();
< 	my_spectrumViewer. hide ();
< 	my_correlationViewer. hide ();
< 	my_tiiViewer. hide ();
< 	my_snrViewer. hide ();
< 	if (my_dabProcessor != nullptr)
< 	   delete	my_dabProcessor;
< 	if (inputDevice != nullptr)
< 	   delete	inputDevice;
< 
< 	delete		soundOut;
< 	delete	my_history;
< 	delete	my_timeTable;
< //	close();
< 	fprintf (stderr, ".. end the radio silences\n");
< }
< 
< //
< static size_t previous_idle_time	= 0;
< static size_t previous_total_time	= 0;
< 
< void	RadioInterface::updateTimeDisplay() {
< 	if (!running. load())
< 	   return;
< 	
< 	numberofSeconds ++;
< 	int16_t	numberHours	= numberofSeconds / 3600;
< 	int16_t	numberMinutes	= (numberofSeconds / 60) % 60;
< 	QString text = QString ("runtime ") + 
< 	               QString::number (numberHours) + " hr, "
< 	               + QString::number (numberMinutes) + " min";
< 	runtimeDisplay	-> setText (text);
< 	if ((numberofSeconds % 2) == 0) {
< 	   size_t idle_time, total_time;
< 	   get_cpu_times (idle_time, total_time);
< 	   const float idle_time_delta = idle_time - previous_idle_time;
< 	   const float total_time_delta = total_time - previous_total_time;
< 	   const float utilization = 100.0 * (1.0 - idle_time_delta / total_time_delta);
< 	   configWidget. cpuMonitor -> display (utilization);
< 	   previous_idle_time = idle_time;
< 	   previous_total_time = total_time;
< 	}
< //
< //	The timer runs autonomously, so it might happen
< //	that it rings when there is no processor running
< 	if (my_dabProcessor == nullptr)
< 	   return;
< 
< 	if (error_report && (numberofSeconds % 10) == 0) {
< 	   int	totalFrames;
< 	   int	goodFrames;
< 	   int	badFrames;
< 	   my_dabProcessor	-> getFrameQuality (&totalFrames,
< 	                                            &goodFrames,
< 	                                            &badFrames);
< 	   fprintf (stderr, "total %d, good %d bad %d ficRatio %f\n",
< 	                     totalFrames, goodFrames, badFrames,
< 	                                            total_ficError * 100.0 / total_fics);
< 	   total_ficError	= 0;
< 	   total_fics		= 0;
< #ifndef TCP_STREAMER 
< #ifndef	QT_AUDIO
< 	   if (configWidget. streamoutSelector -> isVisible ()) {
< 	      int xxx = ((audioSink *)soundOut)	-> missed();
< 	      fprintf (stderr, "missed %d\n", xxx);
< 	   }
< #endif
< #endif
< 	}
< }
< //
< //	precondition: everything is quiet
< deviceHandler	*RadioInterface::setDevice (const QString &s) {
< QString	file;
< deviceHandler	*inputDevice	= nullptr;
< //	OK, everything quiet, now let us see what to do
< 
< 	channel. realChannel	= true;		// until proven otherwise
< #ifdef	HAVE_SDRPLAY_V2
< 	if (s == "sdrplay-v2") {
< #ifdef	__MINGW32__
< 	   QMessageBox::warning (this, tr ("Warning"),
< 	                            tr ("If SDRuno is installed with drivers 3.10,\nV2.13 drivers will not work anymore, choose \"sdrplay\" instead\n"));
< #endif
< 	   try {
< 	      inputDevice	= new sdrplayHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      std::string s;
< 	      switch (e) {
< 	         case 23:
< 	            s = "could not fetch library";
< 	            break;
< 	         case 24:
< 	            s = "one or more library functions could not be loaded";
< 	            break;
< 	         case 25:
< 	         case 26:
< 	            s = "Error in API version";
< 	            break;
< 	         case 27:
< 	            s = "Could not detect a device\n";
< 	            break;
< 	         case 28:
< 	            s = "Could not set the device";
< 	            break;
< 	         default:
< 	            s = "Unidentified error";
< 	      }
< 	      s = "SDRplay: " + s + "\n";
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                               tr (s. c_str ()));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_SDRPLAY_V3
< 	if (s == "sdrplay") {
< 	   try {
< 	      inputDevice	= new sdrplayHandler_v3 (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int errorCode) {
< 	      std::string errorString;
< 	      switch (errorCode) {
< 	         case 1:
< 	            errorString = "Could not fetch library";
< 	            break;
< 	         case 2:
< 	            errorString = "error in fetching functions from library";
< 	            break;
< 	         case 3:
< 	            errorString = "sdrplay_api_Open failed";
< 	            break;
< 	         case 4:
< 	            errorString = "could not open sdrplay_api_ApiVersion";
< 	            break;
< 	         case 5:
< 	            errorString = "API versions do not match";
< 	            break;
< 	         case 6:
< 	            errorString = "sdrplay_api_GetDevices failed";
< 	            break;
< 	         case 7:
< 	            errorString = "no valid device found";
< 	            break;
< 	         case 8:
< 	            errorString = "sdrplay_api_SelectDevice failed";
< 	            break;
< 	         case 9:
< 	            errorString = "sdrplay_api_GetDeviceParams failed";
< 	            break;
< 	         case 10:
< 	            errorString = "sdrplay_api+GetDeviceParams returns null";
< 	            break;
< 	         default:
< 	            errorString = "unidentified error with sdrplay device";
< 	            break;
< 	      }
< 	      
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                               tr (errorString. c_str ()));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_RTLSDR
< 	if (s == "dabstick") {
< 	   try {
< 	      inputDevice	= new rtlsdrHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                           tr ("DAB stick not found! Please use one with RTL2832U or similar chipset!\n"));
< 	      fprintf (stderr, "error = %d\n", e);
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_AIRSPY
< 	if (s == "airspy") {
< 	   try {
< 	      inputDevice	= new airspyHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                           tr ("Airspy or Airspy mini not found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_HACKRF
< 	if (s == "hackrf") {
< 	   try {
< 	      inputDevice	= new hackrfHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                           tr ("hackrf not found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_LIME
< 	if (s == "limeSDR") {
< 	   try {
< 	      inputDevice = new limeHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("no lime device found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_PLUTO_2
< 	if (s == "pluto") {
< 	   try {
< 	      inputDevice = new plutoHandler (dabSettings, version);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      switch (e) {
< 	         case 22:
< 	            QMessageBox::warning (this, tr ("warning"),
< 	                                  tr ("failed to open libiio.dll\n"));
< 	            return nullptr;
< 	         case 23:
< 	            QMessageBox::warning (this, tr ("warning"),
< 	                                 tr ("error in loading functions\n"));
< 	            return nullptr;
< 	         case 24:
< 	            QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("no pluto device found\n"));
< 	            return nullptr;
< 	         default:
< 	            QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("some else with pluto\n"));
< 	            return nullptr;
< 	      }
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_PLUTO_RXTX
< 	if (s == "pluto-rxtx") {
< 	   try {
< 	      inputDevice = new plutoHandler (dabSettings,
< 	                                      version, fmFrequency);
< 	      showButtons();
< 	      streamerOut = new dabStreamer (48000, 192000,
< 	                                       (plutoHandler *)inputDevice);
< 	      ((plutoHandler *)inputDevice)	-> startTransmitter (
< 	                                               fmFrequency);
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("no pluto device found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef HAVE_RTL_TCP
< //	RTL_TCP might be working. 
< 	if (s == "rtl_tcp") {
< 	   try {
< 	      inputDevice = new rtl_tcp_client (dabSettings);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                           tr ("rtl_tcp: no luck\n") );
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_ELAD
< 	if (s == "elad-s1") {
< 	   try {
< 	      inputDevice = new eladHandler (dabSettings);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("no elad device found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef	HAVE_SOAPY
< 	if (s == "soapy") {
< 	   try {
< 	      inputDevice	= new soapyHandler (dabSettings);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                                  tr ("no soapy device found\n"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< #ifdef HAVE_EXTIO
< //	extio is - in its current settings - for Windows, it is a
< //	wrap around the dll
< 	if (s == "extio") {
< 	   try {
< 	      inputDevice = new extioHandler (dabSettings);
< 	      showButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                            tr ("extio: no luck\n") );
< 	      return nullptr;
< 	   }
< 	}
< 	else
< #endif
< 	if (s == "xml files") {
< 	   file		= QFileDialog::getOpenFileName (this,
< 	                                                tr ("Open file ..."),
< 	                                                QDir::homePath(),
< 	                                                tr ("xml data (*.*)"));
< 	   if (file == QString (""))
< 	      return nullptr;
< 	   file		= QDir::toNativeSeparators (file);
< 	   try {
< 	      inputDevice	= new xml_fileReader (file);
< 	      channel. realChannel	= false;
< 	      hideButtons();
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                               tr ("file not found"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< 	if ((s == "file input(.iq)") || (s == "file input(.raw)")) {
< 	   const char *p;
< 	   if (s == "file input(.iq)")
< 	      p = "iq data (*iq)";
< 	   else
< 	      p = "raw data (*raw)";
< 	   
< 	   file		= QFileDialog::getOpenFileName (this,
< 	                                                tr ("Open file ..."),
< 	                                                QDir::homePath(),
< 	                                                tr (p));
< 	   if (file == QString (""))
< 	      return nullptr;
< 	   file		= QDir::toNativeSeparators (file);
< 	   try {
< 	      inputDevice	= new rawFiles (file);
< 	      hideButtons();
< 	      channel. realChannel	= false;
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                               tr ("file not found"));
< 	      return nullptr;
< 	   }
< 	}
< 	else
< 	if (s == "file input(.sdr)") {
< 	   file		= QFileDialog::getOpenFileName (this,
< 	                                                tr ("Open file ..."),
< 	                                                QDir::homePath(),
< 	                                                tr ("raw data (*.sdr)"));
< 	   if (file == QString (""))
< 	      return nullptr;
< 
< 	   file		= QDir::toNativeSeparators (file);
< 	   try {
< 	      inputDevice	= new wavFiles (file);
< 	      channel. realChannel	= false;
< 	      hideButtons ();	
< 	   }
< 	   catch (int e) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                               tr ("file not found"));
< 	      return nullptr;
< 	   }
< 	}
< 	else {
< 	   fprintf (stderr, "unknown device, failing\n");
< 	   return nullptr;
< 	}
< //
< //	It took some code, but it seems we have a device
< 	my_spectrumViewer. setBitDepth (inputDevice -> bitDepth());
< //
< //	do we want to see the widget for device control?
< 	if (dabSettings -> value ("deviceVisible", 0). toInt ()) {
< 	   inputDevice  -> show ();
< 	}
< 	else 
< 	   inputDevice -> hide ();
< 
< 	return inputDevice;
< }
< //
< //	newDevice is called from the GUI when selecting a device
< //	with the selector
< void	RadioInterface::newDevice (const QString &deviceName) {
< //	Part I : stopping all activities
< 	running. store (false);
< 	stopChannel	();
< 	disconnectGUI	();
< 	if (inputDevice != nullptr) {
< 	   delete inputDevice;
< 	   fprintf (stderr, "device is deleted\n");
< 	   inputDevice = nullptr;
< 	}
< 	LOG ("selecting ", deviceName);
< 	inputDevice		= setDevice (deviceName);
< 	if (inputDevice == nullptr) {
< 	   inputDevice = new deviceHandler ();
< 	   return;		// nothing will happen
< 	}
< 	if (dabSettings -> value ("deviceVisible", 1). toInt () != 0)
< 	   inputDevice -> show ();
< 	else
< 	   inputDevice -> hide ();
< 	doStart();		// will set running
< }
< 
< void	RadioInterface::handle_devicewidgetButton	() {
< 	if (inputDevice == nullptr)
< 	   return;
< 
< 	if (inputDevice -> isHidden ()) {
< 	   inputDevice -> show ();
< 	}
< 	else {
< 	   inputDevice -> hide ();
< 	}
< 
< 	dabSettings -> setValue ("deviceVisible",
< 	                      inputDevice -> isHidden () ? 0 : 1);
< }
< 
< ///////////////////////////////////////////////////////////////////////////
< //	signals, received from ofdm_decoder for which that data is
< //	to be displayed
< ///////////////////////////////////////////////////////////////////////////
< 
< static
< const char *monthTable [] = {
< 	"jan", "feb", "mar", "apr", "may", "jun",
< 	"jul", "aug", "sep", "oct", "nov", "dec"
< };
< //
< //	called from the fibDecoder
< void	RadioInterface::clockTime (int year, int month, int day,
< 	                           int hours, int minutes,
< 	                               int d2, int h2, int m2, int seconds){
< 	this	-> localTime. year	= year;
< 	this	-> localTime. month	= month;
< 	this	-> localTime. day	= day;
< 	this	-> localTime. hour	= hours;
< 	this	-> localTime. minute	= minutes;
< 	this	-> localTime. second	= seconds;
< 
< #ifdef	CLOCK_STREAMER
< 	uint8_t	localBuffer [10];
< 	localBuffer [0] = 0xFF;
< 	localBuffer [1] = 0x00;
< 	localBuffer [2] = 0xFF;
< 	localBuffer [3] = 0x00;
< 	localBuffer [4] = (year & 0xFF00) >> 8;
< 	localBuffer [5] = year & 0xFF;
< 	localBuffer [6] = month;
< 	localBuffer [7] = day;
< 	localBuffer [8] = minutes;
< 	localBuffer [9] = seconds;
< 	if (running. load())
< 	   clockStreamer -> sendData (localBuffer, 10);
< #endif
< 	this	-> UTC. year		= year;
< 	this	-> UTC. month		= month;
< 	this	-> UTC. day		= d2;
< 	this	-> UTC. hour		= h2;
< 	this	-> UTC. minute		= m2;
< 	QString result;
< 	if (configWidget. utcSelector -> isChecked ())
< 	   result	= convertTime (year, month, day, h2, m2);
< 	else
< 	   result	= convertTime (year, month, day,
< 	                                     hours, minutes);
< 	localTimeDisplay -> setText (result);
< }
< 
< QString	RadioInterface::convertTime (int year, int month,
< 	                             int day, int hours, int minutes) {
< char dayString [3];
< char hourString [3];
< char minuteString [3];
< 	sprintf (dayString, "%.2d", day);
< 	sprintf (hourString, "%.2d", hours);
< 	sprintf (minuteString, "%.2d", minutes);
< 	QString result = QString::number (year) + "-" +
< 	                       monthTable [month - 1] + "-" +
< 	                       QString (dayString) + "  " +
< 	                       QString (hourString) + ":" +
< 	                       QString (minuteString);
< 	return result;
< }
< //
< //	called from the MP4 decoder
< void	RadioInterface::show_frameErrors (int s) {
< 	if (!running. load ()) 
< 	   return;
< 	QPalette p      = techData. frameError_display -> palette();
< 	if (100 - 4 * s < 80)
< 	   p. setColor (QPalette::Highlight, Qt::red);
< 	else
< 	   p. setColor (QPalette::Highlight, Qt::green);
< 
< 	techData. frameError_display	-> setPalette (p);
< 	techData. frameError_display	-> setValue (100 - 4 * s);
< }
< //
< //	called from the MP4 decoder
< void	RadioInterface::show_rsErrors (int s) {
< 	if (!running. load ())		// should not happen
< 	   return;
< 	QPalette p      = techData. rsError_display -> palette();
< 	if (100 - 4 * s < 80)
< 	   p. setColor (QPalette::Highlight, Qt::red);
< 	else
< 	   p. setColor (QPalette::Highlight, Qt::green);
< 	techData. rsError_display	-> setPalette (p);
< 	techData. rsError_display	-> setValue (100 - 4 * s);
< }
< //
< //	called from the aac decoder
< void	RadioInterface::show_aacErrors (int s) {
< 	if (!running. load ())
< 	   return;
< 
< 	QPalette p      = techData. aacError_display -> palette();
< 	if (100 - 4 * s < 80)
< 	   p. setColor (QPalette::Highlight, Qt::red);
< 	else
< 	   p. setColor (QPalette::Highlight, Qt::green);
< 	techData. aacError_display	-> setPalette (p);
< 	techData. aacError_display	-> setValue (100 - 4 * s);
< }
< //
< //	called from the ficHandler
< void	RadioInterface::show_ficSuccess (bool b) {
< 	if (!running. load ())	
< 	   return;
< 
< 	if (b) 
< 	   ficSuccess ++;
< 
< 	if (++ficBlocks >= 100) {
< 	   QPalette p      = configWidget. ficError_display -> palette();
< 	   if (ficSuccess < 85)
< 	      p. setColor (QPalette::Highlight, Qt::red);
< 	   else
< 	      p. setColor (QPalette::Highlight, Qt::green);
< 
< 	   configWidget. ficError_display	-> setPalette (p);
< 	   configWidget. ficError_display	-> setValue (ficSuccess);
< 	   total_ficError	+= 100 - ficSuccess;
< 	   total_fics		+= 100;
< 	   ficSuccess		= 0;
< 	   ficBlocks		= 0;
< 	}
< }
< //
< //	called from the PAD handler
< void	RadioInterface::show_motHandling (bool b) {
< 	if (!running. load () || !b)
< 	   return;
< 	techData. motAvailable -> 
< 	            setStyleSheet (b ?
< 	                   "QLabel {background-color : green; color: white}":
< 	                   "QLabel {background-color : red; color : white}");
< }
< 	
< //	called from the dabProcessor
< void	RadioInterface::show_snr (int s) {
< 	if (!running. load ())
< 	   return;
< 	configWidget. snrDisplay	-> display (s);
< 	
< 	if (my_snrViewer. isHidden ()) {
< 	   snrBuffer. FlushRingBuffer ();
< 	   return;
< 	}
< 
< 	int amount = snrBuffer. GetRingBufferReadAvailable ();
< 	if (amount <= 0)
< 	   return;
< 
< 	float ss [amount];
< 	snrBuffer. getDataFromBuffer (ss, amount);
< 	for (int i = 0; i < amount; i ++) {
< 	   my_snrViewer. add_snr (ss [i]);
< 	}
< 	my_snrViewer. show_snr ();
< }
< 
< //	just switch a color, called from the dabprocessor
< void	RadioInterface::setSynced	(bool b) {
< }
< //
< //	called from the PAD handler
< 
< void	RadioInterface::showLabel	(QString s) {
< #ifdef	HAVE_PLUTO_RXTX
< 	if (streamerOut != nullptr)
< 	   streamerOut -> addRds (std::string (s. toUtf8 (). data ()));
< #endif
< 	if (running. load()) {
< 	   dynamicLabel -> setWordWrap (true);
< 	   dynamicLabel	-> setText (s);
< 	}
< //	if we dtText is ON, some work is still to be done
< 	if (dlTextFile == nullptr)
< 	   return;
< 	if (the_dlCache. addifNew (s))
< 	   return;
< 	QString currentChannel = channel. channelName;
< 	QDateTime theDateTime	= QDateTime::currentDateTime ();
< 	fprintf (dlTextFile, "%s.%s %4d-%02d-%02d %02d:%02d:%02d  %s\n",
< 	                          currentChannel. toUtf8 (). data (),
< 	                          currentService. serviceName.
< 	                                          toUtf8 (). data (),
< 	                          localTime. year,
< 	                          localTime. month,
< 	                          localTime. day,
< 	                          localTime. hour,
< 	                          localTime. minute,
< 	                          localTime. second,
< 	                          s. toUtf8 (). data ());
< }
< 
< void	RadioInterface::setStereo	(bool b) {
< 	if (!running. load ())
< 	   return;
< 	if (stereoSetting == b)
< 	   return;
< 	techData. stereoLabel	-> setStyleSheet (b ?
< 	   	         "QLabel {background-color: green; color : white}":
< 	   	         "QLabel {background-color: red; color : white}");
< 	techData. stereoLabel	-> setText (b ? "stereo" : "mono");
< 	stereoLabel	-> setStyleSheet (b ?
< 	   	         "QLabel {background-color: green; color : white}":
< 	   	         "QLabel {background-color: red; color : white}");
< 	stereoLabel	-> setText (b ? "stereo" : "mono");
< 	stereoSetting = b;
< }
< //
< //	In this version we show the spectrum even when the
< //	mainId and subId did not change
< 
< void	RadioInterface::show_null (int amount) {
< std::complex<float> B [amount];
< QVector<float> V (amount);
< 	tiiBuffer. getDataFromBuffer (B, amount);
< 	for (int i = 0; i < amount; i ++)
< 	   V [i] = abs (B [i]);
< 	my_tiiViewer. show_nullPeriod (V, 100);
< }
< 
< static
< QString	tiiNumber (int n) {
< 	if (n >= 10)
< 	   return QString::number (n);
< 	return QString ("0") + QString::number (n);
< }
< 
< void	RadioInterface::show_tii_spectrum	() {
< 	my_tiiViewer. showSpectrum (1);
< }
< 
< void	RadioInterface::show_tii	(int mainId, int subId) {
< QString a = "Est: ";
< bool	found	= false;
< QString	country	= "";
< bool	tiiChange	= false;
< 
< 	if (mainId == 0xFF) 
< 	   return;
< 
< 	for (int i = 0; i < (int)(transmitters. size ()); i += 2) {
< 	   if ((transmitters. at (i) == (mainId & 0x7F)) &&
< 	       (transmitters. at (i + 1) == subId)) {
< 	      found = true;
< 	      break;
< 	   }
< 	}
< 
< 	if (!found) {
< 	   transmitters. append (mainId & 0x7F);
< 	   transmitters. append (subId);
< 	}
< 
< 	if (!running. load())
< 	   return;
< 
< 	if ((mainId != channel. mainId) ||
< 	    (subId != channel. subId)) {
< 	   LOG ("tii numbers", tiiNumber (mainId) + " " + tiiNumber (subId));
< 	   tiiChange = true;
< 	}
< 
< 	channel. mainId	= mainId;
< 	channel. subId	= subId;
< 
< 	a = a + " " +  tiiNumber (mainId) + " " + tiiNumber (subId);
< 	transmitter_coordinates	-> setAlignment (Qt::AlignRight);
< 	transmitter_coordinates	-> setText (a);
< 	my_tiiViewer. showTransmitters (transmitters);
< 
< //	if - for the first time now - we see an ecc value,
< //	we check whether or not a tii files is available
< 	if (!channel. has_ecc && (my_dabProcessor -> get_ecc () != 0)) {
< 	   channel. ecc_byte	= my_dabProcessor -> get_ecc ();
< 	   country		= find_ITU_code (channel. ecc_byte,
< 	                                         (channel. Eid >> 12) &0xF);
< 	   channel. has_ecc	= true;
< 	   channel. transmitterName = "";
< 	}
< 
< 	if ((country != "") && (country != channel. countryName)) {
< 	   transmitter_country	-> setText (country);
< 	   channel. countryName	= country;
< 	   LOG ("country", channel. countryName);
< 	}
< 
< 	if (!channel. tiiFile) 
< 	   return;
< 
< 	if (!(tiiChange || (channel. transmitterName == "")))
< 	   return;
< 
< 	if (tiiProcessor. is_black (channel. Eid, mainId, subId)) 
< 	   return;
< 
< 	QString theName =
< 	         tiiProcessor. get_transmitterName (channel. realChannel?
< 	                                               channel. channelName :
< 	                                               "any",
< //	                                            channel. countryName,
< 	                                            channel. Eid,
< 	                                            mainId, subId);
< 	if (theName == "") {
< 	   tiiProcessor. set_black (channel. Eid, mainId, subId);
< 	   LOG ("Not found ", QString::number (channel. Eid, 16) + " " +
< 	                      QString::number (mainId) + " " +
< 	                      QString::number (subId));
< 	   return;
< 	}
< 
< //	if (theName == channel. transmitterName) // already there
< //	   return;
< 
< 	channel. transmitterName = theName;
< 	float latitude, longitude, power;
< 	tiiProcessor. get_coordinates (&latitude, &longitude, &power,
< 	                               channel. realChannel ?
< 	                                  channel. channelName :
< 	                                  "any",
< 	                               theName);
< 	channel. targetPos	= std::complex<float> (latitude, longitude);
< 	LOG ("transmitter ", channel. transmitterName);
< 	LOG ("coordinates ", QString::number (latitude) + " " +
< 	                        QString::number (longitude));
< 	LOG ("current SNR ", QString::number (configWidget. snrDisplay -> value ()));
< 	QString labelText =  channel. transmitterName;
< //
< //      if our own position is known, we show the distance
< //
< 	float ownLatitude	= real (channel. localPos);
< 	float ownLongitude	= imag (channel. localPos);
< 
< 	if ((ownLatitude == 0) || (ownLongitude == 0))
< 	   return;
< 
< 	int distance	= tiiProcessor. distance (latitude,
< 	                                          longitude,
< 	                                          ownLatitude,
< 	                                          ownLongitude);
< 	int hoek	 = tiiProcessor.  corner (latitude,
< 	                                          longitude,
< 	                                          ownLatitude,
< 	                                          ownLongitude);
< 	LOG ("distance ", QString::number (distance));
< 	LOG ("corner ", QString::number (hoek));
< 	labelText +=  + " " + QString::number (distance) + " km" +
< 	                               " " + QString::number (hoek);
< 	labelText += QString::fromLatin1 (" \xb0 ");
< 	fprintf (stderr, "%s\n", labelText. toUtf8 (). data ());
< 	distanceLabel -> setText (labelText);
< 
< //	see if we have a map
< 	if (mapHandler == nullptr) 
< 	   return;
< 
< 	uint8_t key = MAP_NORM_TRANS;
< 	if ((!transmitterTags_local) && (distance > maxDistance)) { 
< 	   maxDistance = distance;
< 	   key = MAP_MAX_TRANS;
< 	}
< //
< //	to be certain, we check
< 	if (channel. targetPos == std::complex<float> (0, 0) ||
< 	                                  (distance == 0) || (hoek == 0))
< 	   return;
< 
< 	QDateTime theTime = 
< 	   configWidget.  utcSelector -> isChecked () ?
< 	                  QDateTime::currentDateTimeUtc () :
< 	                  QDateTime::currentDateTime ();
< 
< 	mapHandler -> putData (key,
< 	                       channel. targetPos, 
< 	                       channel. transmitterName,
< 	                       channel. channelName,
< //	                       theTime. toString (Qt::ISODate),
< 	                       theTime. toString (Qt::TextDate),
< 	                       channel. mainId * 100 + channel. subId,
< 	                       distance, hoek, power);
< }
< 
< void	RadioInterface::showSpectrum	(int32_t amount) {
< 	if (!running. load())
< 	   return;
< 
< 	my_spectrumViewer. showSpectrum (amount,
< 				         inputDevice -> getVFOFrequency());
< }
< 
< void	RadioInterface::showIQ		(int amount) {
< 	if (!running. load())
< 	   return;
< 
< 	my_spectrumViewer. showIQ (amount);
< }
< 
< void	RadioInterface::showQuality	(float q, float timeOffset,
< 	                                 float sco, float freqOffset) {
< 	if (!running. load())
< 	   return;
< 
< 	my_spectrumViewer. showQuality (q, timeOffset, sco, freqOffset);
< }
< 
< //
< //	called from the MP4 decoder
< void	RadioInterface::show_rsCorrections	(int c) {
< 	if (!running)
< 	   return;
< 
< 	techData. rsCorrections	-> display (c);
< }
< //
< //	called from the DAB processor
< void	RadioInterface::show_clockError	(int e) {
< 	if (!running. load ())
< 	   return;
< 
< 	my_spectrumViewer. show_clockErr (e);
< }
< //
< //	called from the phasesynchronizer
< void	RadioInterface::showCorrelation	(int amount, int marker,
< 	                                               QVector<int> v) {
< 	if (!running. load())
< 	   return;
< 	my_correlationViewer. showCorrelation (amount, marker, v);
< 	channel. nrTransmitters = v. size ();
< }
< 
< ////////////////////////////////////////////////////////////////////////////
< 
< void	RadioInterface:: set_streamSelector (int k) {
< 	if (!running. load ())
< 	   return;
< #if	not defined (TCP_STREAMER) &&  not defined (QT_AUDIO)
< 	((audioSink *)(soundOut)) -> selectDevice (k);
< #else
< 	(void)k;
< #endif
< }
< 
< void	RadioInterface::switchVisibility (QWidget *w) {
< 	if (w -> isHidden ())
< 	   w  -> show ();
< 	else
< 	   w -> hide ();
< }
< 
< void	RadioInterface::handle_detailButton	() {
< 	if (!running. load ())
< 	   return;
< 	switchVisibility (&dataDisplay);
< 	if (dataDisplay. isHidden ())
< 	   my_timeTable -> hide ();
< }
< //
< //	Whenever the input device is a file, some functions,
< //	e.g. selecting a channel, setting an alarm, are not
< //	meaningful
< void	RadioInterface::showButtons		() {
< 	configWidget. dumpButton	-> show	();
< 	configWidget. frequencyDisplay	-> show ();
< 	scanButton		-> show ();
< 	channelSelector		-> show ();
< 	nextChannelButton	-> show ();
< 	prevChannelButton	-> show ();
< 	presetSelector		-> show ();
< }
< 
< void	RadioInterface::hideButtons		() {
< 	configWidget. dumpButton		-> hide	();
< 	configWidget. frequencyDisplay	-> hide ();
< 	scanButton		-> hide ();
< 	channelSelector		-> hide ();
< 	nextChannelButton	-> hide ();
< 	prevChannelButton	-> hide ();
< 	presetSelector		-> hide ();
< }
< 
< void	RadioInterface::setSyncLost	() {
< }
< 
< void	RadioInterface::handle_resetButton	() {
< 	if (!running. load())
< 	   return;
< 
< 	stopChannel ();
< 	startChannel	(channelSelector -> currentText ());
< }
< //
< ////////////////////////////////////////////////////////////////////////
< //
< //	dump handling
< //
< /////////////////////////////////////////////////////////////////////////
< 
< void	setButtonFont (QPushButton *b, QString text, int size) {
< 	QFont font	= b -> font ();
< 	font. setPointSize (size);
< 	b		-> setFont (font);
< 	b		-> setText (text);
< 	b		-> update ();
< }
< 
< void	RadioInterface::stop_sourceDumping	() {
< 	if (rawDumper == nullptr) 
< 	   return;
< 
< 	my_dabProcessor	-> stopDumping();
< 	sf_close (rawDumper);
< 	rawDumper	= nullptr;
< 	setButtonFont (configWidget. dumpButton, "Raw dump", 10);
< }
< //
< void	RadioInterface::start_sourceDumping () {
< QString deviceName	= inputDevice -> deviceName ();
< QString channelName	= channel. channelName;
< 	
< 	if (scanning. load ())
< 	   return;
< 
< 	rawDumper	=
< 	         filenameFinder. findRawDump_fileName (deviceName, channelName);
< 	if (rawDumper == nullptr)
< 	   return;
< 
< 	setButtonFont (configWidget. dumpButton, "writing", 12);
< 	my_dabProcessor -> startDumping (rawDumper);
< }
< 
< void	RadioInterface::handle_sourcedumpButton () {
< 	if (!running. load () || scanning. load ())
< 	   return;
< 
< 	if (rawDumper != nullptr)
< 	   stop_sourceDumping ();
< 	else
< 	   start_sourceDumping ();
< }
< 
< void	RadioInterface::stop_audioDumping	() {
< 	if (audioDumper == nullptr)
< 	   return;
< 
< 	soundOut	-> stopDumping();
< 	sf_close (audioDumper);
< 	audioDumper	= nullptr;
< 	setButtonFont (techData. audiodumpButton, "audio dump", 10);
< }
< 
< void	RadioInterface::start_audioDumping () {
< 	audioDumper	=
< 	      filenameFinder.
< 	           findAudioDump_fileName  (serviceLabel -> text (), true);
< 	if (audioDumper == nullptr)
< 	   return;
< 
< 	setButtonFont (techData. audiodumpButton, "writing", 12);
< 	soundOut	-> startDumping (audioDumper);
< }
< 
< void	RadioInterface::scheduled_audioDumping () {
< 	if (audioDumper != nullptr) {
< 	   soundOut	-> stopDumping();
< 	   sf_close (audioDumper);
< 	   audioDumper	= nullptr;
< 	   setButtonFont (techData. audiodumpButton, "audio dump", 10);
< 	   return;
< 	}
< 	audioDumper	=
< 	      filenameFinder.
< 	            findAudioDump_fileName  (serviceLabel -> text (), false);
< 	if (audioDumper == nullptr)
< 	   return;
< 
< 	setButtonFont (techData. audiodumpButton, "writing", 12);
< 	soundOut	-> startDumping (audioDumper);
< }
< 
< void	RadioInterface::handle_audiodumpButton () {
< 	if (!running. load () || scanning. load ())
< 	   return;
< 
< 	if (audioDumper != nullptr) 
< 	   stop_audioDumping ();	
< 	else
< 	   start_audioDumping ();
< }
< 
< void	RadioInterface::stop_frameDumping () {
< 	if (frameDumper == nullptr)
< 	   return;
< 
< 	fclose (frameDumper);
< 	setButtonFont (techData. framedumpButton, "frame dump", 10);
< 	frameDumper	= nullptr;
< }
< 
< void	RadioInterface::start_frameDumping () {
< 	frameDumper	=
< 	     filenameFinder. findFrameDump_fileName (serviceLabel -> text (),
< 	                                                              true);
< 	if (frameDumper == nullptr)
< 	   return;
< 	setButtonFont (techData. framedumpButton, "recording", 12);
< }
< 
< void	RadioInterface::scheduled_frameDumping (const QString &s) {
< 	if (frameDumper != nullptr) {
< 	   fclose (frameDumper);
< 	   setButtonFont (techData. framedumpButton, "frame dump", 10);
< 	   frameDumper	= nullptr;
< 	   return;
< 	}
< 	   
< 	frameDumper	=
< 	     filenameFinder. findFrameDump_fileName (s, false);
< 	if (frameDumper == nullptr)
< 	   return;
< 	setButtonFont (techData. framedumpButton, "recording", 12);
< }
< 
< void	RadioInterface::handle_framedumpButton () {
< 	if (!running. load () || scanning. load ())
< 	   return;
< 
< 	if (frameDumper != nullptr) 
< 	   stop_frameDumping ();
< 	else
< 	   start_frameDumping ();
< }
< //
< //	called from the mp4 handler, using a signal
< void    RadioInterface::newFrame        (int amount) {
< uint8_t buffer [amount];
< 	if (!running. load ())
< 	   return;
< 
< 	if (frameDumper == nullptr) 
< 	   frameBuffer. FlushRingBuffer ();
< 	else
< 	while (frameBuffer. GetRingBufferReadAvailable () >= amount) {
< 	   frameBuffer. getDataFromBuffer (buffer, amount);
< 	   if (frameDumper != nullptr)
< 	      fwrite (buffer, amount, 1, frameDumper);
< 	}
< }
< 
< void	RadioInterface::handle_tiiButton	() {
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_tiiViewer. isHidden())
< 	   my_tiiViewer. show();
< 	else
< 	   my_tiiViewer. hide();
< }
< 
< void	RadioInterface::handle_correlationButton	() {
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_correlationViewer. isHidden())
< 	   my_correlationViewer. show();
< 	else
< 	   my_correlationViewer. hide();
< }
< 
< void	RadioInterface::handle_spectrumButton	() {
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_spectrumViewer. isHidden())
< 	   my_spectrumViewer. show ();
< 	else
< 	   my_spectrumViewer. hide ();
< }
< 
< void	RadioInterface::handle_snrButton	() {
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_snrViewer. isHidden ())
< 	   my_snrViewer. show ();
< 	else
< 	   my_snrViewer. hide ();
< }
< 
< void    RadioInterface::handle_historyButton    () {
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_history  -> isHidden ())
< 	   my_history   -> show ();
< 	else
< 	   my_history   -> hide ();
< }
< //
< //	When changing (or setting) a device, we do not want anybody
< //	to have the buttons on the GUI touched, so
< //	we just disconnet them and (re)connect them as soon as
< //	a device is operational
< void	RadioInterface::connectGUI	() {
< 	connect (configWidget. contentButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_contentButton ()));
< 	connect (detailButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_detailButton ()));
< 	connect (configWidget. resetButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_resetButton ()));
< 	connect (scanButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_scanButton ()));
< 	connect (configWidget. show_tiiButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_tiiButton ()));
< 	connect (configWidget. show_correlationButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_correlationButton ()));
< 	connect (configWidget. show_spectrumButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_spectrumButton ()));
< 	connect (configWidget. snrButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_snrButton ()));
< 	connect (configWidget. devicewidgetButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_devicewidgetButton ()));
< 	connect (historyButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_historyButton ()));
< 	connect (configWidget. dumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_sourcedumpButton ()));
< 
< 	connect (nextChannelButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_nextChannelButton ()));
< 	connect	(prevChannelButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_prevChannelButton ()));
< 	connect (prevServiceButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_prevServiceButton ()));
< 	connect (nextServiceButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_nextServiceButton ()));
< 
< 	connect (techData. audiodumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_audiodumpButton ()));
< 	connect (techData. framedumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_framedumpButton ()));
< 	connect (muteButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_muteButton ()));
< 	connect (configWidget. scheduleButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_scheduleButton ()));
< 
< 	connect (ensembleDisplay, SIGNAL (clicked (QModelIndex)),
< 	         this, SLOT (selectService (QModelIndex)));
< 
< 	connect (configWidget. muteTimeSetting, SIGNAL (valueChanged (int)),
< 	         this, SLOT (handle_muteTimeSetting (int)));
< 	connect (configWidget. switchDelaySetting,
< 	                                 SIGNAL (valueChanged (int)),
< 	         this, SLOT (handle_switchDelaySetting (int)));
< 	connect (configWidget. orderAlfabetical, SIGNAL (clicked ()),
< 	         this, SLOT (handle_orderAlfabetical ()));
< 	connect (configWidget. orderServiceIds, SIGNAL (clicked ()),
< 	         this, SLOT (handle_orderServiceIds ()));
< 	connect (configWidget. ordersubChannelIds, SIGNAL (clicked ()),
< 	         this, SLOT (handle_ordersubChannelIds ()));
< 	connect (configWidget. scanmodeSelector,
< 	                            SIGNAL (currentIndexChanged (int)),
< 	         this, SLOT (handle_scanmodeSelector (int)));
< 	connect (configWidget. saveServiceSelector, SIGNAL (stateChanged (int)),
< 	         this, SLOT (handle_saveServiceSelector (int)));
< 	connect (configWidget. skipList_button, SIGNAL (clicked ()),
< 	         this, SLOT (handle_skipList_button ()));
< 	connect (configWidget. skipFile_button, SIGNAL (clicked ()),
< 	         this, SLOT (handle_skipFile_button ()));
< }
< 
< void	RadioInterface::disconnectGUI() {
< 	disconnect (configWidget. contentButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_contentButton ()));
< 	disconnect (detailButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_detailButton ()));
< 	disconnect (configWidget. resetButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_resetButton ()));
< 	disconnect (scanButton, SIGNAL (clicked ()),
< 	           this, SLOT (handle_scanButton ()));
< 	disconnect (configWidget. show_tiiButton, SIGNAL (clicked ()),
< 	               this, SLOT (handle_tiiButton ()));
< 	disconnect (configWidget. show_correlationButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_correlationButton ()));
< 	disconnect (configWidget. show_spectrumButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_spectrumButton ()));
< 	disconnect (configWidget. snrButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_snrButton ()));
< 	disconnect (configWidget. devicewidgetButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_devicewidgetButton ()));
< 	disconnect (historyButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_historyButton ()));
< 	disconnect (configWidget. dumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_sourcedumpButton ()));
< 	disconnect (nextChannelButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_nextChannelButton ()));
< 	disconnect (prevChannelButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_prevChannelButton ()));
< 	disconnect (prevServiceButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_prevServiceButton ()));
< 	disconnect (nextServiceButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_nextServiceButton ()));
< 
< 	disconnect (techData. audiodumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_audiodumpButton ()));
< 	disconnect (techData. framedumpButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_framedumpButton ()));
< 	disconnect (muteButton, SIGNAL (clicked ()),
< 	         this, SLOT (handle_muteButton ()));
< 	disconnect (configWidget. scheduleButton, SIGNAL (clicked ()),
< 	            this, SLOT (handle_scheduleButton ()));
< 
< 	disconnect (ensembleDisplay, SIGNAL (clicked (QModelIndex)),
< 	         this, SLOT (selectService (QModelIndex)));
< 
< 	disconnect (configWidget. muteTimeSetting,
< 	                                    SIGNAL (valueChanged (int)),
< 	            this, SLOT (handle_muteTimeSetting (int)));
< 	disconnect (configWidget. switchDelaySetting,
< 	                                    SIGNAL (valueChanged (int)),
< 	            this, SLOT (handle_switchDelaySetting (int)));
< 	disconnect (configWidget. orderAlfabetical, SIGNAL (clicked ()),
< 	            this, SLOT (handle_orderAlfabetical ()));
< 	disconnect (configWidget. orderServiceIds, SIGNAL (clicked ()),
< 	            this, SLOT (handle_orderServiceIds ()));
< 	disconnect (configWidget. ordersubChannelIds, SIGNAL (clicked ()),
< 	            this, SLOT (handle_ordersubChannelIds ()));
< 	disconnect (configWidget. scanmodeSelector, SIGNAL (currentIndexChanged (int)),
< 	            this, SLOT (handle_scanmodeSelector (int)));
< 	disconnect (configWidget. saveServiceSelector, SIGNAL (stateChanged (int)),
< 	            this, SLOT (handle_saveServiceSelector (int)));
< 	disconnect (configWidget. skipList_button, SIGNAL (clicked ()),
< 	            this, SLOT (handle_skipList_button ()));
< 	disconnect (configWidget. skipFile_button, SIGNAL (clicked ()),
< 	            this, SLOT (handle_skipFile_button ()));
< }
< //
< #include <QCloseEvent>
< void RadioInterface::closeEvent (QCloseEvent *event) {
< 	int x = configWidget. closeDirect -> isChecked () ? 1 : 0;
< 	dabSettings -> setValue ("closeDirect", x);
< 	if (x != 0) {
< 	   TerminateProcess ();
< 	   event -> accept ();
< 	   return;
< 	}
< 
< 	QMessageBox::StandardButton resultButton =
< 	                QMessageBox::question (this, "dabRadio",
< 	                                       tr("Are you sure?\n"),
< 	                                       QMessageBox::No | QMessageBox::Yes,
< 	                                       QMessageBox::Yes);
< 	if (resultButton != QMessageBox::Yes) {
< 	   event -> ignore();
< 	} else {
< 	   TerminateProcess ();
< 	   event -> accept();
< 	}
< }
< 
< bool	RadioInterface::eventFilter (QObject *obj, QEvent *event) {
< 	if (!running. load ())
< 	   return QWidget::eventFilter (obj, event);
< 
< 	if (my_dabProcessor == nullptr) {
< 	   fprintf (stderr, "expert error 5\n");
< 	   return true;
< 	}
< 
< 	if (event -> type () == QEvent::KeyPress) {
< 	   QKeyEvent *ke = static_cast <QKeyEvent *> (event);
< 	   if (ke -> key () == Qt::Key_Return) {
< 	      presetTimer. stop ();
< 	      nextService. valid = false;
< 	      QString serviceName =
< 	         ensembleDisplay -> currentIndex ().
< 	                             data (Qt::DisplayRole). toString ();
< 	      if (currentService. serviceName != serviceName) {
< 	         fprintf (stderr, "currentservice = %s (%d)\n",
< 	                  currentService. serviceName. toUtf8 (). data (),
< 	                                currentService. valid);
< 	         stopService (currentService);
< 	         currentService. valid =  false;
< 	         selectService (ensembleDisplay -> currentIndex ());
< 	         stopScanning (false);
< 	      }
< 	   }
< 	}
< 	else
< 	if ((obj == this -> my_history -> viewport ()) &&
< 	    (event -> type () == QEvent::MouseButtonPress)) {
< 	   QMouseEvent *ev = static_cast<QMouseEvent *>(event);
< 	   if (ev -> buttons () & Qt::RightButton) {
< 	      my_history -> clearHistory ();
< 	   }
< 	}
< 	else
< 	if ((obj == this -> ensembleDisplay -> viewport()) &&
< 	    (event -> type() == QEvent::MouseButtonPress )) {
< 	   QMouseEvent *ev = static_cast<QMouseEvent *>(event);
< 	   if (ev -> buttons() & Qt::RightButton) {
< 	      audiodata ad;
< 	      packetdata pd;
< 	      QString serviceName =
< 	           this -> ensembleDisplay -> indexAt (ev -> pos()). data ().toString();
< 	      serviceName = serviceName. right (16);
< //	      if (serviceName. at (1) == ' ')
< //	         return true;
< 	      my_dabProcessor -> dataforAudioService (serviceName, &ad);
< 	      if (ad. defined && (serviceLabel -> text () == serviceName)) {
< 	         presetData pd;
< 	         pd. serviceName	= serviceName;
< 	         pd. channel		= channelSelector -> currentText ();
< 	         QString itemText	= pd. channel + ":" + pd. serviceName;
< 	         for (int i = 0; i < presetSelector -> count (); i ++)
< 	            if (presetSelector -> itemText (i) == itemText)
< 	               return true;
< 	         presetSelector -> addItem (itemText);
< 	         return true;
< 	      }
< 
< 	      if ((ad. defined) && (ad. ASCTy == 077)) {
< 	         for (uint16_t i = 0; i < backgroundServices. size (); i ++) {
< 	            if (backgroundServices. at (i). serviceName ==
< 	                                                      serviceName) {
< 	               fprintf (stderr, "Hiero\n");
< 	                my_dabProcessor -> stopService (ad. subchId,
< 	                                                      BACK_GROUND);
< 	                if (backgroundServices. at (i). fd != nullptr)
< 	                   fclose (backgroundServices. at (i). fd);
< 	                backgroundServices. erase
< 	                        (backgroundServices. begin () + i);
< 	                fprintf (stderr, "Background %s gestopt\n",
< 	                                     serviceName. toUtf8 (). data ());
< 
< 	                for (int j = 0; j < model. rowCount (); j ++) {
< 	                    QString itemText =
< 	                           model. index (j, 0). data (Qt::DisplayRole). toString ();
< 	                   if (itemText == serviceName) {
< 	                      colorService (model. index (j, 0), Qt::black, fontSize);
< 	                   }
< 	                }
< 	                return true;
< 	            }
< 	         }
< 	         FILE *f =
< 	            filenameFinder. findFrameDump_fileName (serviceName, true);
< 	         if (f == nullptr)
< 	            return true;
< 
< 	         (void)my_dabProcessor ->
< 	                   set_audioChannel (&ad, &audioBuffer, f, BACK_GROUND);
< 	         
< 	         dabService s;
< 	         s. channel	= ad. channel;
< 	         s. serviceName	= ad. serviceName;
< 	         s. SId		= ad. SId;
< 	         s. SCIds	= ad. SCIds;
< 	         s. subChId	= ad. subchId;
< 	         s. fd		= f;
< 	         backgroundServices. push_back (s);
< 	         for (int j = 0; j < model. rowCount (); j ++) {
< 	             QString itemText =
< 	               model. index (j, 0). data (Qt::DisplayRole). toString ();
< 	               if (itemText == s. serviceName) {
< 	                  colorService (model. index (j, 0),
< 	                                       Qt::blue, fontSize + 2, true);
< 	               }
< 		 }
< 	         return true;
< 	      }
< 	   }
< 	}
< 
< 	return QWidget::eventFilter (obj, event);
< }
< 
< void	RadioInterface::startAnnouncement (const QString &name, int subChId) {
< 	if (!running. load ())
< 	   return;
< 
< 	if (name == serviceLabel -> text ()) {
< 	   serviceLabel	-> setStyleSheet ("QLabel {color : red}");
< 	   fprintf (stderr, "announcement for %s (%d) starts\n",
< 	                             name. toUtf8 (). data (), subChId);
< 	}
< }
< 
< void	RadioInterface::stopAnnouncement (const QString &name, int subChId) {
< 	(void)subChId;
< 	if (!running. load ())
< 	   return;
< 
< 	if (name == serviceLabel -> text ()) {
< 	   serviceLabel ->
< 	              setStyleSheet ("QLabel {color : black}");
< 	   fprintf (stderr, "end for announcement service %s\n",
< 	                              name. toUtf8 (). data ());
< 	}
< }
< 
< ////////////////////////////////////////////////////////////////////////
< //
< //	preset selection, either from presets or from history
< ////////////////////////////////////////////////////////////////////////
< 
< void    RadioInterface::handle_historySelect (const QString &s) {
< 	if (!running. load ())
< 	   return;
< 
< 	presetTimer. stop ();
< 	localSelect (s);
< }
< 
< void    RadioInterface::handle_presetSelector (const QString &s) {
< 	if (!running. load ())
< 	   return;
< 
< 	presetTimer. stop ();
< 	if ((s == "Presets") || (presetSelector -> currentIndex () == 0))
< 	   return;
< 	fprintf (stderr, "going for %s\n", s. toUtf8 (). data ());
< 	localSelect (s);
< }
< 
< void	RadioInterface::handle_contentSelector (const QString &s) {
< 	if (!running. load ())
< 	   return;
< 
< 	presetTimer. stop ();
< 	fprintf (stderr, "going for %s\n", s. toUtf8 (). data ());
< 	localSelect (s);
< }
< 
< 
< void	RadioInterface::localSelect (const QString &s) {
< #if QT_VERSION >= 0x060000
< 	QStringList list = s.split (":", Qt::SkipEmptyParts);
< #else
< 	QStringList list = s.split (":", QString::SkipEmptyParts);
< #endif
< 	if (list. length () != 2)
< 	   return;
< 	localSelect (list. at (0), list. at (1));
< }
< 
< //
< //	From a predefined schedule list, the service names most
< //	likely are less than 16 characters
< //
< void	RadioInterface::scheduleSelect (const QString &s) {
< #if QT_VERSION >= 0x060000
< 	QStringList list = s.split (":", Qt::SkipEmptyParts);
< #else
< 	QStringList list = s.split (":", QString::SkipEmptyParts);
< #endif
< 	if (list. length () != 2)
< 	   return;
< 	QString theChannel = list. at (0);
< 	QString service	= list. at (1);
< 	for (int i = service. size (); i < 16; i ++)
< 	   service. append (' ');
< 
< 	fprintf (stderr, "going for channel %s, service %s\n",
< 	                   theChannel. toUtf8(). data (),
< 	                   service. toUtf8 (). data ());
< 	localSelect (theChannel, service);
< }
< 
< void	RadioInterface::localSelect (const QString &theChannel,
< 	                             const QString &service) {
< int	switchDelay;
< 	stopScanning (false);
< 	if (my_dabProcessor == nullptr) {
< 	   fprintf (stderr, "Expert error 21\n");
< 	   return;
< 	}
< 
< 	if (theChannel == channel. channelName) {
< 	   stopService (currentService);
< 	   currentService. valid = false;
< 	   dabService s;
< 	   my_dabProcessor -> getParameters (service, &s. SId, &s. SCIds);
< 	   if (s. SId == 0) {
< 	      QMessageBox::warning (this, tr ("Warning"),
< 	                         tr ("insufficient data for this program\n"));
< 	      return;
< 	   }
< 	   s. serviceName = service;
< 	   startService (&s);
< 	   return;
< 	}
< //
< //	The hard part is stopping the current service,
< //      selecting a new channel,
< //      waiting a while
< 	stopChannel ();
< //      trying to start the selected service
< 	int k           = channelSelector -> findText (theChannel);
< 	if (k != -1) {
< 	   new_channelIndex (k);
< 	}
< 	else {
< 	   QMessageBox::warning (this, tr ("Warning"),
< 	                               tr ("Incorrect preset\n"));
< 	   return;
< 	}
< 
< 	nextService. valid		= true;
< 	nextService. channel		= theChannel;
< 	nextService. serviceName        = service;
< 	nextService. SId                = 0;
< 	nextService. SCIds              = 0;
< 	presetTimer. setSingleShot (true);
< 	switchDelay			=
< 	                  dabSettings -> value ("switchDelay", 8). toInt ();
< 	presetTimer. setInterval (switchDelay * 1000);
< 	presetTimer. start (switchDelay * 1000);
< 	startChannel    (channelSelector -> currentText ());
< }
< 
< ////////////////////////////////////////////////////////////////////////////
< //
< //	handling services: stop and start
< ///////////////////////////////////////////////////////////////////////////
< 
< void	RadioInterface::stopService	(dabService &s) {
< 	presetTimer. stop ();
< 	channelTimer. stop ();
< 	stop_muting	();
< 
< 	techData. timeTable_button -> hide ();
< 	my_timeTable	-> hide ();
< 
< 	if (my_dabProcessor == nullptr) {
< 	   fprintf (stderr, "Expert error 22\n");
< 	   return;
< 	}
< 
< 	if (frameDumper != nullptr) {
< 	   stop_frameDumping ();
< 	}
< 
< 	if (audioDumper != nullptr) {
< 	   stop_audioDumping ();
< 	}
< 	if (s. valid) {
< 	   my_dabProcessor -> stopService (s. subChId, FORE_GROUND);
< 	   if (s. is_audio) {
< 	      soundOut -> stop ();
< 	      for (int i = 0; i < 5; i ++) {
< 	         packetdata pd;
< 	         my_dabProcessor -> dataforPacketService (s. serviceName,
< 	                                                        &pd, i);
< 	         if (pd. defined) {
< 	            my_dabProcessor -> stopService (pd. subchId, FORE_GROUND);
< 	            break;
< 	         }
< 	      }
< 	   }
< //
< //	The name of the service - on stopping it - will be - normally -
< //	made back again in the service list. An exception is when another
< //	instance of the service runs as background process, then the
< //	name should be made green, italic
< 	   for (int i = 0; i < model. rowCount (); i ++) {
< 	      QString itemText =
< 	          model. index (i, 0). data (Qt::DisplayRole). toString ();
< 	      if (itemText != s. serviceName) 
< 	         continue;
< 	      for (uint16_t j = 0; j < backgroundServices. size (); j ++) {
< 	         if (backgroundServices. at (j). serviceName ==
< 	                                              s. serviceName) {
< 	            colorService (model. index (i, 0),
< 	                          Qt::blue, fontSize + 2, true);
< 	           cleanScreen ();
< 	           return;
< 	         }
< 	      }	// ok, service is not background as well
< 	      colorService (model. index (i, 0), Qt::black, fontSize);
< 	      break;
< 	   }
< 	}
< 	show_pauzeSlide ();
< 	cleanScreen	();
< }
< //
< //
< void	RadioInterface::selectService (QModelIndex ind) {
< QString	currentProgram = ind. data (Qt::DisplayRole). toString ();
< 
< 	if (!running. load ())
< 	   return;
< 
< 	if (my_dabProcessor == nullptr) {	// should/can not happen
< 	   fprintf (stderr, "Expert error 7\n");
< 	   fprintf (stderr, "no service should be visible\n");
< 	   return;
< 	}
< 
< 	presetTimer.	stop	();
< 	channelTimer.	stop	();
< 	stopScanning	(false);
< 
< 	stopService 	(currentService);		// if any
< 	currentService. valid = false;
< 
< 	dabService s;
< 	s. serviceName = currentProgram;
< 	my_dabProcessor -> getParameters (currentProgram, &s. SId, &s. SCIds);
< 	if (s. SId == 0) {
< 	   QMessageBox::warning (this, tr ("Warning"),
<  	                         tr ("insufficient data for this program\n"));	
< 	   return;
< 	}
< 
< 	startService (&s);
< }
< //
< void	RadioInterface::startService (dabService *s) {
< QString serviceName	= s -> serviceName;
< 
< 	currentService		= *s;
< 	currentService. valid	= false;
< 	LOG ("start service ", serviceName. toUtf8 (). data ());
< 	LOG ("service has SNR ", QString::number (configWidget. snrDisplay -> value ()));
< 	techData. timeTable_button -> hide ();
< //
< //	mark the selected service in the service list
< 	int rowCount	= model. rowCount ();
< 	for (int i = 0; i < rowCount; i ++) {
< 	   QString itemText =
< 	           model. index (i, 0). data (Qt::DisplayRole). toString ();
< 	   if (itemText ==  serviceName) {
< 	      colorService (model. index (i, 0), Qt::red, fontSize + 4);
< 	      QFont font = serviceLabel -> font ();
< 	      font. setPointSize (20);
< 	      font. setBold (true);
< 	      serviceLabel	-> setFont (font);
< 	      serviceLabel	-> setText (serviceName);
< 	      audiodata ad;
< 	      
< 	      my_dabProcessor -> dataforAudioService (serviceName, &ad);
< 	      if (ad. defined) {
< 	         currentService. valid		= true;
< 	         currentService. is_audio	= true;
< 	         currentService. subChId	= ad. subchId;
< 	         if (my_dabProcessor -> has_timeTable (ad. SId))
< 	            techData. timeTable_button -> show ();
< 	         start_audioService (&ad);
< 	         if (dabSettings -> value ("has-presetName", 0).
< 	                                                   toInt () == 1) {
< 	            QString s = channel. channelName + ":" + serviceName;
< 	            dabSettings	-> setValue ("presetname", s);
< 	         }
< 	         else 
< 	            dabSettings	-> setValue ("presetname", "");
< #ifdef	HAVE_PLUTO_RXTX
< 	        if (streamerOut != nullptr)
< 	           streamerOut -> addRds (std::string (serviceName. toUtf8 (). data ()));
< #endif
< 	      }
< 	      else
< 	      if (my_dabProcessor -> is_packetService (serviceName)) {
< 	         packetdata pd;
< 	         my_dabProcessor -> dataforPacketService (serviceName, &pd, 0);
< 	         currentService. valid		= true;
< 	         currentService. is_audio	= false;
< 	         currentService. subChId	= pd. subchId;
< 	         start_packetService (serviceName);
< 	      }
< 	      else {
< 	         fprintf (stderr, "%s is not clear\n",
< 	                            serviceName. toUtf8 (). data ());
< 	         dabSettings	-> setValue ("presetname", "");
< 	      }
< 	      return;
< 	   }
< 	}
< }
< 
< void    RadioInterface::colorService (QModelIndex ind, QColor c, int pt,
< 	                                                         bool italic) {
< 	QMap <int, QVariant> vMap = model. itemData (ind);
< 	vMap. insert (Qt::ForegroundRole, QVariant (QBrush (c)));
< 	model. setItemData (ind, vMap);
< 	model. setData (ind, QFont (theFont, pt, -1, italic), Qt::FontRole);
< }
< //
< //	This function is only used in the Gui to clear
< //	the details of a selected service
< void	RadioInterface::cleanScreen	() {
< 	serviceLabel			-> setText ("");
< 	dynamicLabel			-> setText ("");
< //	distanceLabel			-> setText ("");
< 
< 	new_presetIndex (0);
< 	stereoLabel	-> setStyleSheet {
< 	      my_dabProcessor -> dataforAudioService (serviceName, &ad);
< 	   ed. programType =
< 	      ad. programType;
< 	}
< 	serviceOrder	=
< 	    dabSettings -> value ("serviceOrder", ALPHA_BASED). toInt ();
< 
< 	serviceList = insert (serviceList, ed, serviceOrder);
< 	my_history -> addElement (channel. channelName, serviceName);
< 	model. clear ();
< 	for (auto serv : serviceList) {
< 	    model. appendRow (new QStandardItem (serv. name));
3360,3366c1059,1063
< #ifdef	XXX
< 	fprintf (stderr, "handle_MOT: type %x (%x %x), name %s dir = %d\n",
< 	                           contentType,
< 	                           getContentBaseType ((MOTContentType)contentType),
< 	                           getContentSubType ((MOTContentType)contentType),
< 	                           objectName. toUtf8 (). data (), dirElement);
< #endif
---
> //	fprintf (stderr, "handle_MOT: type %x (%x %x), name %s dir = %d\n",
> //	                           contentType,
> //	                           getContentBaseType ((MOTContentType)contentType),
> //	                           getContentSubType ((MOTContentType)contentType),
> //	                           objectName. toUtf8 (). data (), dirElement);
4599d2295
< //	                       theTime. toString (Qt::ISODate),
5520,5524d3215
< 	stereoLabel	-> setStyleSheet {
< 	techData. stereoLabel	-> setStyleSheet (
< 	   	         "QLabel {background-color: red; color : black}");
< 	stereoLabel	-> setText ("");
< 	programTypeLabel	=> setText ("");
5579,5580d3269
< 	
< 	setText (getProgramType (ad -> programType));
5606a3296,3297
> //	   setText (the_textMapper.
> //	               get_programm_type_string (ad -> programType));
6165c3856
< 	   if ((serv. name == b. name) && (serv. channel == b. channel))
---
> 	   if (serv. name == b. name)
